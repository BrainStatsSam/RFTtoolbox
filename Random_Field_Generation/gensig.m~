function Sig = gensig( Mag, Rad, Smo, Dim, centre_locs )
% GENSIG( Mag, Rad, Smo, Dim, centre_locs ) generates signal with peaks at
% locations within an image of dimension Dim. The nth peak is created by
% generating a spheroid (with dimension according to the dimension of the image)
% of signal of height 1 with radius Rad(n) and then smoothing this with a
% Gaussian kernel with FWHM: Smo(n). This is then scaled 
%--------------------------------------------------------------------------
% ARGUMENTS
% Mag       is a vector of length npeaks giving the magnitude of the 
%           resulting signal at each peak.
% Rad       is a vector of length npeaks giving the radius of the spheroid 
%           signal at each peak prior to being smoothed.
% Smo       is a vector of length npeaks that gives the smoothing applied
%           to the signal at each peak. The smoothing applied is Gaussian 
%           with the same FWHM in each x,y and z directions.
% Dim       the dimension of the output image
% centre_locs   is a vector of length npeaks giving the coordinates of the 
%               centre locations of each peak.
%--------------------------------------------------------------------------
% OUTPUT
% data      an image of dimension Dim with peaks centred at the locations
%           specified by centre_locs.
%--------------------------------------------------------------------------
% EXAMPLES
% %3D signal
% Sig = gensig(2, 10, 6);
% surf(Sig(:,:,50))
%--------------------------------------------------------------------------
% SEE ALSO
% SimDemo

%Set to sum(100*clock) to ensure that this is different each time.
randn('seed',sum(100*clock));   %-Random number generator initializaiton

%DEFAULT VARS

if nargin < 1
    Mag = 2;
end
if nargin < 2
    Rad = 10;
end
if nargin < 3
    Smo = 6;
end
if nargin < 4
    Dim = [91, 109, 91];
end
if nargin < 5
    centre_locs = {Dim/2 + 1/2};
end
    
npeaks = length(centre_locs);
if length(Mag) == 1
    Mag = repmat(Mag, 1, npeaks);
elseif length(Mag) ~= npeaks
    error('The number of peaks in Mag is not the same as in centre_peaks')
end

if length(Rad) == 1
    Rad = repmat(Rad, 1, npeaks);
elseif length(Rad) ~= npeaks
    error('The number of peaks in Rad is not the same as in centre_peaks')
end

if length(Smo) == 1
    Smo = repmat(Smo, 1, npeaks);
elseif length(Smo) ~= npeaks
    error('The number of peaks in Smo is not the same as in centre_peaks')
end

rimFWHM = 1.7;
%-----------Initialization of Some Variables
nDim    = length(Dim);

boundary2add = ceil(rimFWHM*max(Smo(:)))*ones(1,nDim);
wDim    = Dim + 2*boundary2add;  % Working image dimension

for peak = 1:npeaks
    centre_locs{peak} = centre_locs{peak} + boundary2add; % Need to do this to ensure the centre locs are in the right place even after boundary stuff.
end

%Below describes the actual bits of the image other than the extra
%truncation stuff that we have added on!
Trunc_x = {(ceil(rimFWHM*max(Smo(:)))+1):(ceil(rimFWHM*max(Smo(:)))+Dim(1))};
Trunc_y = {(ceil(rimFWHM*max(Smo(:)))+1):(ceil(rimFWHM*max(Smo(:)))+Dim(2))};

if nDim==2
    %Concatenates Trunc_x and Trunc_y into one array. Why is this
    %necessary? 
    TrnInd = cat(2, Trunc_x, Trunc_y); %Note cat(2,A,B) == [A,B]
else
    Trunc_z = {(ceil(rimFWHM*max(Smo(:)))+1):(ceil(rimFWHM*max(Smo(:)))+Dim(3))};
    TrnInd  = cat(2, Trunc_x, Trunc_y, Trunc_z);
end

Sig = zeros(wDim);
for peak = 1:npeaks
    Sig = Sig + SpheroidSignal(wDim, Rad(peak), Mag(peak), Smo(peak), centre_locs{peak}); %- Signal Should smooth here really!!
end

if nDim == 2
    Sig = Sig(TrnInd{1},TrnInd{2});
elseif nDim == 3
    Sig = Sig(TrnInd{1},TrnInd{2}, TrnInd{3});
end

end

